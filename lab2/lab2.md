# Lab2
## phase_1
- 注意利用`disas phase_1` 可以发现需要比较字符串的地址为 `$0x402400`,直接设置断点
- 注意可以使用 `print (char*) 地址`进行字符串的转换
- 最终结果为:
```text
$1 = 0x402400 "Border relations with Canada have never been better."
```
- 注意不要怀疑名称十分明确的函数(比如`string_no_equals`)
## phase_2
- 还是不要被各种函数迷惑,看函数名称即可: `read_six_number`表示读取 `6` 个数字,不重要
- 看一下如下汇编代码:
```asm
   0x0000000000400efc <+0>:	push   %rbp
   0x0000000000400efd <+1>:	push   %rbx
   0x0000000000400efe <+2>:	sub    $0x28,%rsp
   0x0000000000400f02 <+6>:	mov    %rsp,%rsi
   0x0000000000400f05 <+9>:	call   0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:	cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:	je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:	call   0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:	jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:	mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:	add    %eax,%eax
   0x0000000000400f1c <+32>:	cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:	je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:	call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:	add    $0x4,%rbx
   0x0000000000400f29 <+45>:	cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:	jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:	jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:	lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:	lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:	jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:	add    $0x28,%rsp
   0x0000000000400f40 <+68>:	pop    %rbx
   0x0000000000400f41 <+69>:	pop    %rbp
   0x0000000000400f42 <+70>:	ret

```
- `read_six_number`的作用应该是把数字读取到栈中,并且第一个数字位于`%rsp`的位置,接下来判断第一个数字是否是`0x01`也就是`1`,如果是的话那么就会跳转到`52`行,这里设置`%rbx`为`%rsp + 0x04`并且设置`rbp`为`0x18`,之后跳转到`27`行,在`27`行的位置把`%eax`复制为上一次的值,也就是`%rsp`的值`1`,并且进行`%eax`的累加和`%rbx`比较(此时`%rbx`已经向后面移动了),所以以此类推,其实每一次就是上一个数字为下一个数字的两倍即可,当`%rbx = %rbp`终止,此时的数字个数为`0x18 - 0x04 / 4 = 6`
- 所以最后的答案为:
```text
1 2 4 8 16 32
```
## phase_3
- 得到的汇编代码如下:
```x86
   0x0000000000400f43 <+0>:	sub    $0x18,%rsp
   0x0000000000400f47 <+4>:	lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:	lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:	mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:	mov    $0x0,%eax
   0x0000000000400f5b <+24>:	call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:	cmp    $0x1,%eax
   0x0000000000400f63 <+32>:	jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:	call   0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:	cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:	ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:	mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:	jmp    *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:	mov    $0xcf,%eax
   0x0000000000400f81 <+62>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:	mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:	mov    $0x100,%eax
   0x0000000000400f8f <+76>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:	mov    $0x185,%eax
   0x0000000000400f96 <+83>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:	mov    $0xce,%eax
   0x0000000000400f9d <+90>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:	mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:	mov    $0x147,%eax
   0x0000000000400fab <+104>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:	call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:	mov    $0x0,%eax
   0x0000000000400fb7 <+116>:	jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:	mov    $0x137,%eax
   0x0000000000400fbe <+123>:	cmp    0xc(%rsp),%eax
--Type <RET> for more, q to quit, c to continue without paging--c
   0x0000000000400fc2 <+127>:	je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:	call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:	add    $0x18,%rsp
   0x0000000000400fcd <+138>:	ret
```
- 首先明确`sscanf`的用法:
```cpp
int sscanf(const char* str , const char* format , [addr]);
// 比如
sscanf("1:2","%d:%d",&a,&b);
```
- 如下语句:
```x86
   0x0000000000400f47 <+4>:	lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:	lea    0x8(%rsp),%rdx
```
- 作用其实就是让这两个寄存器存放`%rsp + 0xc`和`%rsp + 0x8`位置的最终取值的地址,也就是作为参数(本生就是指针),`%rdx`表示第二个参数,`%rcx`表示第三个参数
- 利用: `print (char*) 0x4025cf` 可以得到: "%d %d"所以需要输入两个整数
- 另外由于两个参数分别是: `%rcx`和`%rdx`,所以最终,`%rsp + 0x8` 中存储这第一个参数,`%rsp + 0xc`中存储着第二个参数,可以利用如下命令查看:
```asm
print *(int*) ($rsp + 0x8) 
```
- 注意到下面的命令,表示第一个参数必须小于或者等于`7`:
```asm
 0x0000000000400f6a <+39>:	cmpl   $0x7,0x8(%rsp)
```
- 接下来就是一些分支结构了:
```asm
  0x0000000000400f75 <+50>:	jmp    *0x402470(,%rax,8)
```
- 上面一个命令的含义就是跳转到地址为`0x402470 + $rax * 8` 的位置,可以使用如下命令查看:
```gdb
print /x *(int*) (0x402470 + $rax * 8) 查看
```
- 跳转到指令的位置之后设置`$eax`为指定的常量并且和`123`行的第二个参数进行比较即可,只要输入的第二个参数和第一个参数对应即可,所以答案如下(任意取一组即可):
```text
0 207
1 311
2 707
3 256
4 389
5 206
6 682
7 327
```
## phase_4
- 搞清楚递归函数的逻辑即可,比较简单
- `disas phase_4`可以得到:
```x86
   0x000000000040100c <+0>:	sub    $0x18,%rsp
   0x0000000000401010 <+4>:	lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:	lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:	mov    $0x4025cf,%esi
   0x000000000040101f <+19>:	mov    $0x0,%eax
   0x0000000000401024 <+24>:	call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:	cmp    $0x2,%eax
   0x000000000040102c <+32>:	jne    0x401035 <phase_4+41>
   0x000000000040102e <+34>:	cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 <+39>:	jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:	call   0x40143a <explode_bomb>
   0x000000000040103a <+46>:	mov    $0xe,%edx
   0x000000000040103f <+51>:	mov    $0x0,%esi
   0x0000000000401044 <+56>:	mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:	call   0x400fce <func4>
   0x000000000040104d <+65>:	test   %eax,%eax
   0x000000000040104f <+67>:	jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:	cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 <+74>:	je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:	call   0x40143a <explode_bomb>
   0x000000000040105d <+81>:	add    $0x18,%rsp
   0x0000000000401061 <+85>:	ret

```
- 还是一样的情况: `%rsp + 0x8` 表示第一个参数,`%rsp + 0xc`  表示第二个参数
- 看一下初始化参数的准备:
```x86
   0x000000000040103a <+46>:	mov    $0xe,%edx
   0x000000000040103f <+51>:	mov    $0x0,%esi
   0x0000000000401044 <+56>:	mov    0x8(%rsp),%edi
```
- 也就是`edx = 0xe , esi = 0x0 , edi = 第一个参数`
- `disas func4`可以得到:
```x86
 0x0000000000400fce <+0>:	sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:	mov    %edx,%eax
   0x0000000000400fd4 <+6>:	sub    %esi,%eax
   0x0000000000400fd6 <+8>:	mov    %eax,%ecx
   0x0000000000400fd8 <+10>:	shr    $0x1f,%ecx
   0x0000000000400fdb <+13>:	add    %ecx,%eax
   0x0000000000400fdd <+15>:	sar    $1,%eax
   0x0000000000400fdf <+17>:	lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 <+20>:	cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:	jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:	lea    -0x1(%rcx),%edx
   0x0000000000400fe9 <+27>:	call   0x400fce <func4>
   0x0000000000400fee <+32>:	add    %eax,%eax
   0x0000000000400ff0 <+34>:	jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:	mov    $0x0,%eax
   0x0000000000400ff7 <+41>:	cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:	jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:	lea    0x1(%rcx),%esi
   0x0000000000400ffe <+48>:	call   0x400fce <func4>
   0x0000000000401003 <+53>:	lea    0x1(%rax,%rax,1),%eax
   0x0000000000401007 <+57>:	add    $0x8,%rsp
   0x000000000040100b <+61>:	ret
```
- 可以进行计算可以得到 `$edx = 7`,所以在第`22`行就可以跳转到`36`行,`36`行进行一次比较即可,并且这两次比较同时成立表示`第一个参数 = $edx`,当然如果两者不相等就会触发递归函数`func4`,递归函数中每一次`$edx --`重新计算得到的第一个参数也可以
- 在`phase_4`中比较第二个参数,第二个参数必须为`0`
- 所以最终的结果如下:
```x86
7 0
3 0
1 0
0 0
...
```
## phase_5
- 利用`disas phase_5`得到的汇编代码如下:
```x86
   0x0000000000401062 <+0>:	push   %rbx
   0x0000000000401063 <+1>:	sub    $0x20,%rsp
   0x0000000000401067 <+5>:	mov    %rdi,%rbx
   0x000000000040106a <+8>:	mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:	mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:	xor    %eax,%eax
   0x000000000040107a <+24>:	call   0x40131b <string_length>
   0x000000000040107f <+29>:	cmp    $0x6,%eax
   0x0000000000401082 <+32>:	je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:	call   0x40143a <explode_bomb>
   0x0000000000401089 <+39>:	jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:	movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:	mov    %cl,(%rsp)
   0x0000000000401092 <+48>:	mov    (%rsp),%rdx
   0x0000000000401096 <+52>:	and    $0xf,%edx
   0x0000000000401099 <+55>:	movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:	mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:	add    $0x1,%rax
   0x00000000004010a8 <+70>:	cmp    $0x6,%rax
   0x00000000004010ac <+74>:	jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:	movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:	mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:	lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:	call   0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:	test   %eax,%eax
   0x00000000004010c4 <+98>:	je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:	call   0x40143a <explode_bomb>
   0x00000000004010cb <+105>:	nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:	jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:	mov    $0x0,%eax
   0x00000000004010d7 <+117>:	jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:	mov    0x18(%rsp),%rax
--Type <RET> for more, q to quit, c to continue without paging--c
   0x00000000004010de <+124>:	xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:	je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:	call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:	add    $0x20,%rsp
   0x00000000004010f2 <+144>:	pop    %rbx
   0x00000000004010f3 <+145>:	ret
```
- 看懂这一段代码(添加如下注释):
- 注意`movzbl`的作用就是移动一个字节,并且把上`24`位补充为`0`,成为`32`位
- `movsbl`使用原来的值的最高为填充来扩充到`32`位
```x86
   0x000000000040108b <+41>:	movzbl (%rbx,%rax,1),%ecx  # 把 %rbx + %rax * 1 的内容移动到 %ecx中(并且只会移动一个字节,movzbl的作用就是移动一个字节到指定的位置并且把高24为置为0)
   0x000000000040108f <+45>:	mov    %cl,(%rsp) # 把低8位移动到(%rsp)中
   0x0000000000401092 <+48>:	mov    (%rsp),%rdx # 把低8位的内容移动到%rdx中
   0x0000000000401096 <+52>:	and    $0xf,%edx # 保留最后的4位
   0x0000000000401099 <+55>:	movzbl 0x4024b0(%rdx),%edx # 在指定的字符串中划过一定的位数,并且把对应的字符写入到%edx中
   0x00000000004010a0 <+62>:	mov    %dl,0x10(%rsp,%rax,1) # 把得到的字符吸入到 %rsp + %rax + 1 的位置
   0x00000000004010a4 <+66>:	add    $0x1,%rax # 进行 %rax 的递增,也就是可以向后面滑动字母
   0x00000000004010a8 <+70>:	cmp    $0x6,%rax # 判断上界
   0x00000000004010ac <+74>:	jne    0x40108b <phase_5+41> 
   0x00000000004010ae <+76>:	movb   $0x0,0x16(%rsp) # 把字符串的最后一个位置设置为 \0 
   0x00000000004010b3 <+81>:	mov    $0x40245e,%esi  
   0x00000000004010b8 <+86>:	lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:	call   0x401338 <strings_not_equal> # 进行 esi 寄存器中的字符串和指定字符串进行对比
   0x00000000004010c2 <+96>:	test   %eax,%eax
   0x00000000004010c4 <+98>:	je     0x4010d9 <phase_5+119>
```
- 利用 `print (char*) 0x40245e` 可以得到`flyers`
- 利用 `print (char*) 0x4024b0` 可以得到:
```text
maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?
```
- 在比较长的一个字符串中划过指定的距离就可以得到`flyers`,根据距离得到的答案为:
```text
ionefg
```
## phase_6
- 汇编代码演示:
- 第一个部分(利用一个双重循环来判断所有元素都不相等并且都小于`6`):
```asm

   0x00000000004010f4 <+0>:	push   %r14 
   0x00000000004010f6 <+2>:	push   %r13
   0x00000000004010f8 <+4>:	push   %r12
   0x00000000004010fa <+6>:	push   %rbp
   0x00000000004010fb <+7>:	push   %rbx  # 获取各种被调用者保存寄存器
   0x00000000004010fc <+8>:	sub    $0x50,%rsp 
   0x0000000000401100 <+12>:	mov    %rsp,%r13 # %r13指向栈顶
   0x0000000000401103 <+15>:	mov    %rsp,%rsi # %rsi指向栈顶
   0x0000000000401106 <+18>:	call   0x40145c <read_six_numbers> # 读取数字
   0x000000000040110b <+23>:	mov    %rsp,%r14 # r14指向栈顶中的第一个元素
   0x000000000040110e <+26>:	mov    $0x0,%r12d # r12d = 0
   0x0000000000401114 <+32>:	mov    %r13,%rbp # rbp 指向栈顶 | rbp 指向第二个元素
   0x0000000000401117 <+35>:	mov    0x0(%r13),%eax # eax 获取到第一个元素 | eax 获取到第二个元素
   0x000000000040111b <+39>:	sub    $0x1,%eax # eax - 1 
   0x000000000040111e <+42>:	cmp    $0x5,%eax # 判断 eax - 1 <= 5 
   0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52> # 一定需要 eax <= 6 | eax2 <= 6
   0x0000000000401123 <+47>:	call   0x40143a <explode_bomb>
   0x0000000000401128 <+52>:	add    $0x1,%r12d # r12d = 1 | r12d = 2
   0x000000000040112c <+56>:	cmp    $0x6,%r12d # 比较 r12d 和 6 不相等
   0x0000000000401130 <+60>:	je     0x401153 <phase_6+95> # 跳转到 95 行
   0x0000000000401132 <+62>:	mov    %r12d,%ebx # ebx = r12d = 1 | ebx = r12d = 2
   0x0000000000401135 <+65>:	movslq %ebx,%rax # rax = ebx = 1 | rax = ebx = 2 | rax = ebx = 3 | rax = 2
   0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax # 开始移动位置 eax = 第二个元素 | 指向第三个元素 | 指向第四个元素 | 指向第五个元素 | 指向第六个元素 | 指向第三个元素
   0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp) # 比较第二个元素和第一个元素 | 比较第一个元素和第三个元素 | 比较第一个元素和第四个元素 | 比较第一个和第五个元素 | 比较第一和第六个元素
   0x000000000040113e <+74>:	jne    0x401145 <phase_6+81> # 不相等跳转到 81,相等爆炸 | 不相等
   0x0000000000401140 <+76>:	call   0x40143a <explode_bomb>
   0x0000000000401145 <+81>:	add    $0x1,%ebx # ebx += 1 ebx = 2 | ebx = 3 | ebx = 4 | ebx = 5 | ebx = 6
   0x0000000000401148 <+84>:	cmp    $0x5,%ebx  # 比较 ebx 和 5 
   0x000000000040114b <+87>:	jle    0x401135 <phase_6+65> # ebx < 5跳转到 65行
   0x000000000040114d <+89>:	add    $0x4,%r13  # r13指向第二个元素
   0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32> 
```
- 第二个部分(把所有元素设置为 `7 - e`):
```asm
  0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi # 此时 %rsi 继续指向栈最上面元素和上面一个元素
   0x0000000000401158 <+100>:	mov    %r14,%rax # rax 指向栈顶
   0x000000000040115b <+103>:	mov    $0x7,%ecx # ecx = 7
--Type <RET> for more, q to quit, c to continue without paging--c
   0x0000000000401160 <+108>:	mov    %ecx,%edx # edx = 7
   0x0000000000401162 <+110>:	sub    (%rax),%edx # edx = 7 - 第一个元素 | 7 - 第二个元素
   0x0000000000401164 <+112>:	mov    %edx,(%rax) # rax 中存储 7 - 第一个元素(改变数字)
   0x0000000000401166 <+114>:	add    $0x4,%rax  # 到第二个位置
   0x000000000040116a <+118>:	cmp    %rsi,%rax # 判断 rsi 指向的位置和 rax 地址是否一样
   0x000000000040116d <+121>:	jne    0x401160 <phase_6+108> # 不相等进行跳转
```

- 第三个部分(根据每一个元素的大小来对于链表中的节点进行排列,从 0x20 - 0x50):
```asm
   0x000000000040116f <+123>:	mov    $0x0,%esi # 把 esi = 0 rsi = 0
   0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163> # 跳转到 163
   0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx # rdx = 330
   0x000000000040117a <+134>:	add    $0x1,%eax # eax = 2
   0x000000000040117d <+137>:	cmp    %ecx,%eax # 比较 ecx 和 eax
   0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:	mov    $0x6032d0,%edx # edx = 332
   0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2) # rdx = rsp + 32(rdx = 332)
   0x000000000040118d <+153>:	add    $0x4,%rsi # rsi = 0x04
   0x0000000000401191 <+157>:	cmp    $0x18,%rsi # 比较是否到达重点
   0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>
   0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx # ecx = rsp 地址 , rsi = 0 | rei = 4 , ecx = 第二个元素
   0x000000000040119a <+166>:	cmp    $0x1,%ecx # 比较 ecx 和 1
   0x000000000040119d <+169>:	jle    0x401183 <phase_6+143> # <=1 , 可以看存储了多少 332
   0x000000000040119f <+171>:	mov    $0x1,%eax # eax = 1
   0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx # (edx) = 332
   0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130> 
```

- 第四个部分(建立排列好的链表之间的前后关系,也就是让前一个节点的指针指向后面一个节点):
- 注意这里`leap`的作用就是做一个运算,也就是`rax = rsp + 0x20`
```asm
   0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx # mov指令 rbx 中存储第一个节点
   0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax # rax中存储者第二个节点的地址
   0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi # rsi中存储者栈顶的地址
   0x00000000004011ba <+198>:	mov    %rbx,%rcx # rcx 中存储和第一个节点
   0x00000000004011bd <+201>:	mov    (%rax),%rdx # rdx 中存储者第二个节点
                                       # M[rcx + 0x8] = rbx ,也就是下一个节点的地址被替换
   0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx) # 让rcx+0x8其实就是rcx的next成员指针的位置,让成员指针指向 rdx(相当于 &(rcx ->  next) == rdx)
   0x00000000004011c4 <+208>:	add    $0x8,%rax # rax 上移动
   0x00000000004011c8 <+212>:	cmp    %rsi,%rax # 判断是否到底
   0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:	mov    %rdx,%rcx # rcx后移动,相当于 rcx = rcx -> next;
   0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>
```
- 注意节点结构体的内存对齐:
```cpp
struct Node {
   int val;  // 0x0
   struct Node* next; // 0x8 开始
};
```
- 第五部分(进行链表中元素的比较需要链表中的元素为降序排列)
```asm

   0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx) # M[rdx + 8] = 0 , 相当于尾巴节点设置为 NULL
   0x00000000004011da <+230>:	mov    $0x5,%ebp # ebp = 5
   0x00000000004011df <+235>:	mov    0x8(%rbx),%rax # rax = M[rbx + 0x8],相当于 rax 就是 head ->next
   0x00000000004011e3 <+239>:	mov    (%rax),%eax # eax = rax -> data
   0x00000000004011e5 <+241>:	cmp    %eax,(%rbx) # 比较 rax -> data 和 head -> data
   0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250> # 如果 head -> data >= rax -> data 就可以跳转
   0x00000000004011e9 <+245>:	call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx # rbx = M[rbx + 0x8] 其实就是地址
   0x00000000004011f2 <+254>:	sub    $0x1,%ebp # 进行递减比较
   0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:	add    $0x50,%rsp
   0x00000000004011fb <+263>:	pop    %rbx
   0x00000000004011fc <+264>:	pop    %rbp
   0x00000000004011fd <+265>:	pop    %r12
   0x00000000004011ff <+267>:	pop    %r13
   0x0000000000401201 <+269>:	pop    %r14
   0x0000000000401203 <+271>:	ret
```
- 原来节点的顺序为:
```text
332 168 924 691 477 443
# 7 - e的排列
3 4 5 6 1 2
```
- 最终答案为:
```text
4 3 2 1 6 5
```
## 隐藏机关
- 在  `phase_defaused`中进行反编译可以看到条件跳转执行 `secret_phase`函数E
- 触发条件:
```asm
phase 中
0 0 DrEvil
```
- 最终的答案是一个二叉树:
```text
└─ 36
   ├─ 8
   │  ├─ 6
   │  │  ├─ left: 1
   │  │  └─ right: 7
   │  └─ 22
   │     ├─ left: 20
   │     └─ right: 35
   └─ 50
      ├─ 45
      │  ├─ left: 40
      │  └─ right: 47
      └─ 107
         ├─ left: 99
         └─ right: 1001
```
- 汇编代码:
```text
   <!-- 0x0000000000401204 <+0>:	sub    $0x8,%rsp
   0x0000000000401208 <+4>:	test   %rdi,%rdi
   0x000000000040120b <+7>:	je     0x401238 <fun7+52>
   0x000000000040120d <+9>:	mov    (%rdi),%edx
   0x000000000040120f <+11>:	cmp    %esi,%edx
   0x0000000000401211 <+13>:	jle    0x401220 <fun7+28> -->

   0x0000000000401213 <+15>:	mov    0x8(%rdi),%rdi  # 表示 rdi = M[rdi + 0x8]
   0x0000000000401217 <+19>:	call   0x401204 <fun7> # 回调
   0x000000000040121c <+24>:	add    %eax,%eax  # 返回值 *= 2
   0x000000000040121e <+26>:	jmp    0x40123d <fun7+57> # 返回

   <!-- 0x0000000000401220 <+28>:	mov    $0x0,%eax
   0x0000000000401225 <+33>:	cmp    %esi,%edx
   0x0000000000401227 <+35>:	je     0x40123d <fun7+57> -->

   0x0000000000401229 <+37>:	mov    0x10(%rdi),%rdi # rdi = M[rdi + 16]
   0x000000000040122d <+41>:	call   0x401204 <fun7> # 回调
   0x0000000000401232 <+46>:	lea    0x1(%rax,%rax,1),%eax # eax = rax + 1
   0x0000000000401236 <+50>:	jmp    0x40123d <fun7+57> # 返回
   0x0000000000401238 <+52>:	mov    $0xffffffff,%eax
   0x000000000040123d <+57>:	add    $0x8,%rsp
   0x0000000000401241 <+61>:	ret

```
- 也就是如果:
  - 参数 < `%eax` 返回 0
  - 参数 >= `%eax`:
    - 参数 == `%eax`: `rdi = M[rid + 16]` 返回值为 `rax + 1`
    - 参数 < `%eax`:  `rdi = M[rid + 8]`  返回值为 `rax * 2`
- 最终答案:
```txt
22 20
```