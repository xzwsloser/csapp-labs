
   0x00000000004010f4 <+0>:	push   %r14 
   0x00000000004010f6 <+2>:	push   %r13
   0x00000000004010f8 <+4>:	push   %r12
   0x00000000004010fa <+6>:	push   %rbp
   0x00000000004010fb <+7>:	push   %rbx  # 获取各种被调用者保存寄存器
   0x00000000004010fc <+8>:	sub    $0x50,%rsp 
   0x0000000000401100 <+12>:	mov    %rsp,%r13 # %r13指向栈顶
   0x0000000000401103 <+15>:	mov    %rsp,%rsi # %rsi指向栈顶
   0x0000000000401106 <+18>:	call   0x40145c <read_six_numbers> # 读取数字
   0x000000000040110b <+23>:	mov    %rsp,%r14 # r14指向栈顶中的第一个元素
   0x000000000040110e <+26>:	mov    $0x0,%r12d # r12d = 0
   0x0000000000401114 <+32>:	mov    %r13,%rbp # rbp 指向栈顶 | rbp 指向第二个元素
   0x0000000000401117 <+35>:	mov    0x0(%r13),%eax # eax 获取到第一个元素 | eax 获取到第二个元素
   0x000000000040111b <+39>:	sub    $0x1,%eax # eax - 1 
   0x000000000040111e <+42>:	cmp    $0x5,%eax # 判断 eax - 1 <= 5 
   0x0000000000401121 <+45>:	jbe    0x401128 <phase_6+52> # 一定需要 eax <= 6 | eax2 <= 6
   0x0000000000401123 <+47>:	call   0x40143a <explode_bomb>
   0x0000000000401128 <+52>:	add    $0x1,%r12d # r12d = 1 | r12d = 2
   0x000000000040112c <+56>:	cmp    $0x6,%r12d # 比较 r12d 和 6 不相等
   0x0000000000401130 <+60>:	je     0x401153 <phase_6+95> # 跳转到 95 行
   0x0000000000401132 <+62>:	mov    %r12d,%ebx # ebx = r12d = 1 | ebx = r12d = 2
   0x0000000000401135 <+65>:	movslq %ebx,%rax # rax = ebx = 1 | rax = ebx = 2 | rax = ebx = 3 | rax = 2
   0x0000000000401138 <+68>:	mov    (%rsp,%rax,4),%eax # 开始移动位置 eax = 第二个元素 | 指向第三个元素 | 指向第四个元素 | 指向第五个元素 | 指向第六个元素 | 指向第三个元素
   0x000000000040113b <+71>:	cmp    %eax,0x0(%rbp) # 比较第二个元素和第一个元素 | 比较第一个元素和第三个元素 | 比较第一个元素和第四个元素 | 比较第一个和第五个元素 | 比较第一和第六个元素
   0x000000000040113e <+74>:	jne    0x401145 <phase_6+81> # 不相等跳转到 81,相等爆炸 | 不相等
   0x0000000000401140 <+76>:	call   0x40143a <explode_bomb>
   0x0000000000401145 <+81>:	add    $0x1,%ebx # ebx += 1 ebx = 2 | ebx = 3 | ebx = 4 | ebx = 5 | ebx = 6
   0x0000000000401148 <+84>:	cmp    $0x5,%ebx  # 比较 ebx 和 5 
   0x000000000040114b <+87>:	jle    0x401135 <phase_6+65> # ebx < 5跳转到 65行
   0x000000000040114d <+89>:	add    $0x4,%r13  # r13指向第二个元素
   0x0000000000401151 <+93>:	jmp    0x401114 <phase_6+32> 


   0x0000000000401153 <+95>:	lea    0x18(%rsp),%rsi # 此时 %rsi 继续指向栈最上面元素和上面一个元素
   0x0000000000401158 <+100>:	mov    %r14,%rax # rax 指向栈顶
   0x000000000040115b <+103>:	mov    $0x7,%ecx # ecx = 7
--Type <RET> for more, q to quit, c to continue without paging--c
   0x0000000000401160 <+108>:	mov    %ecx,%edx # edx = 7
   0x0000000000401162 <+110>:	sub    (%rax),%edx # edx = 7 - 第一个元素 | 7 - 第二个元素
   0x0000000000401164 <+112>:	mov    %edx,(%rax) # rax 中存储 7 - 第一个元素(改变数字)
   0x0000000000401166 <+114>:	add    $0x4,%rax  # 到第二个位置
   0x000000000040116a <+118>:	cmp    %rsi,%rax # 判断 rsi 指向的位置和 rax 地址是否一样
   0x000000000040116d <+121>:	jne    0x401160 <phase_6+108> # 不相等进行跳转


   0x000000000040116f <+123>:	mov    $0x0,%esi # 把 esi = 0 rsi = 0
   0x0000000000401174 <+128>:	jmp    0x401197 <phase_6+163> # 跳转到 163
   0x0000000000401176 <+130>:	mov    0x8(%rdx),%rdx # rdx = 330
   0x000000000040117a <+134>:	add    $0x1,%eax # eax = 2
   0x000000000040117d <+137>:	cmp    %ecx,%eax # 比较 ecx 和 eax
   0x000000000040117f <+139>:	jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:	jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:	mov    $0x6032d0,%edx # edx = 332
   0x0000000000401188 <+148>:	mov    %rdx,0x20(%rsp,%rsi,2) # rdx = rsp + 32(rdx = 332)
   0x000000000040118d <+153>:	add    $0x4,%rsi # rsi = 0x04
   0x0000000000401191 <+157>:	cmp    $0x18,%rsi # 比较是否到达重点
   0x0000000000401195 <+161>:	je     0x4011ab <phase_6+183>
   0x0000000000401197 <+163>:	mov    (%rsp,%rsi,1),%ecx # ecx = rsp 地址 , rsi = 0 | rei = 4 , ecx = 第二个元素
   0x000000000040119a <+166>:	cmp    $0x1,%ecx # 比较 ecx 和 1
   0x000000000040119d <+169>:	jle    0x401183 <phase_6+143> # <=1 , 可以看存储了多少 332
   0x000000000040119f <+171>:	mov    $0x1,%eax # eax = 1
   0x00000000004011a4 <+176>:	mov    $0x6032d0,%edx # (edx) = 332
   0x00000000004011a9 <+181>:	jmp    0x401176 <phase_6+130> 


   0x00000000004011ab <+183>:	mov    0x20(%rsp),%rbx # mov指令 rbx 中存储第一个节点
   0x00000000004011b0 <+188>:	lea    0x28(%rsp),%rax # rax中存储者第二个节点的地址
   0x00000000004011b5 <+193>:	lea    0x50(%rsp),%rsi # rsi中存储者栈顶的地址
   0x00000000004011ba <+198>:	mov    %rbx,%rcx # rcx 中存储和第一个节点
   0x00000000004011bd <+201>:	mov    (%rax),%rdx # rdx 中存储者第二个节点
                                       # M[rcx + 0x8] = rbx ,也就是下一个节点的地址被替换
   0x00000000004011c0 <+204>:	mov    %rdx,0x8(%rcx) # 让rcx+0x8其实就是rcx的next成员指针的位置,让成员指针指向 rdx(相当于 &(rcx ->  next) == rdx)
   0x00000000004011c4 <+208>:	add    $0x8,%rax # rax 上移动
   0x00000000004011c8 <+212>:	cmp    %rsi,%rax # 判断是否到底
   0x00000000004011cb <+215>:	je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:	mov    %rdx,%rcx # rcx后移动,相当于 rcx = rcx -> next;
   0x00000000004011d0 <+220>:	jmp    0x4011bd <phase_6+201>


   0x00000000004011d2 <+222>:	movq   $0x0,0x8(%rdx) # M[rdx + 8] = 0 , 相当于尾巴节点设置为 NULL
   0x00000000004011da <+230>:	mov    $0x5,%ebp # ebp = 5
   0x00000000004011df <+235>:	mov    0x8(%rbx),%rax # rax = M[rbx + 0x8],相当于 rax 就是 head ->next
   0x00000000004011e3 <+239>:	mov    (%rax),%eax # eax = rax -> data
   0x00000000004011e5 <+241>:	cmp    %eax,(%rbx) # 比较 rax -> data 和 head -> data
   0x00000000004011e7 <+243>:	jge    0x4011ee <phase_6+250> # 如果 head -> data >= rax -> data 就可以跳转
   0x00000000004011e9 <+245>:	call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:	mov    0x8(%rbx),%rbx # rbx = M[rbx + 0x8] 其实就是地址
   0x00000000004011f2 <+254>:	sub    $0x1,%ebp # 进行递减比较
   0x00000000004011f5 <+257>:	jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:	add    $0x50,%rsp
   0x00000000004011fb <+263>:	pop    %rbx
   0x00000000004011fc <+264>:	pop    %rbp
   0x00000000004011fd <+265>:	pop    %r12
   0x00000000004011ff <+267>:	pop    %r13
   0x0000000000401201 <+269>:	pop    %r14
   0x0000000000401203 <+271>:	ret